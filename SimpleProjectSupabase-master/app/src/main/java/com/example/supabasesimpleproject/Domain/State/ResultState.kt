package com.example.supabasesimpleproject.Domain.State

/**
 *  sealed class (запечатанный класс) ResultState, представляющий различные состояния результата асинхронной операции.
 *  Sealed class  означает, что все возможные подтипы этого класса определены непосредственно внутри него.
 *  Это полезно для обеспечения исчерпывающего рассмотрения всех возможных состояний и предотвращения ошибок
 * */

sealed class ResultState {
    data object Loading : ResultState() // Это объект, представляющий состояние загрузки
    data object Initialized : ResultState() //  Это объект, представляющий состояние инициализации
    data class Success(val message: String) : ResultState() //  Это класс, представляющий успешное завершение операции.  Он содержит свойство message типа String, которое может содержать дополнительную информацию о результате
    data class Error(val message: String) : ResultState() //  Это класс, представляющий ошибку.  Он также содержит свойство message типа String,  которое описывает произошедшую ошибку
}
/**
 * Зачем использовать sealed class?
 * Использование sealed class здесь имеет несколько преимуществ:
 *
 * Исчерпывающее рассмотрение: Компилятор Kotlin может проверить, что все возможные состояния ResultState
 * обрабатываются в when-выражении или другом подобном механизме.  Это помогает избежать ошибок, связанных с забытыми состояниями.
 *
 * Более безопасный код:  Гарантируется, что переменная типа ResultState может принимать только один из четырех определенных подтипов.
 * Это повышает безопасность типа и предотвращает ошибки во время выполнения.
 *
 * Читаемость:  sealed class  делает код более читаемым и понятным, так как все возможные состояния явно определены в одном месте
 * */